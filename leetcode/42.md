# 42. Trapping Rain Water

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


Example:

```
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

## Idea

- Solution 1: DP + two pointers
- SOlution 2: Stack

## Code 


### version 0.1  DP + two pointers

``` python 
                     |
          |ðŸ’§ðŸ’§ðŸ’§ðŸ’§ |
|ðŸ’§ðŸ’§ðŸ’§ðŸ’§|ðŸ’§ðŸ’§ðŸ’§ðŸ’§ |
```


- We won't lose any water when the height of the water is less than the shorter bar of two.
- So, we can find the highest bar first and keep track of the shorter one. 
	- If the new bar > the current bar, we update it.
	- Otherwise, we count the difference as water. 



``` python
# Time: O(n) n = len(height)
# Space: O(1)


class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        def find_bar(height):
            bar, b = -1, 0
            for i, height in enumerate(height):
                if height > bar:
                    b, bar = i, height 
            return bar, b
            
        bar, b = find_bar(height)
        water = 0
        
        left_bar = height[0]
        for _, h in enumerate(height[:b]):
            if h > left_bar:
                left_bar = h
            else:
                water += left_bar - h
        
        right_bar = height[-1]
        for _, h in enumerate(height[b+1:][::-1]):
            if h > right_bar:
                right_bar = h
            else:
                water += right_bar - h
        return water 
```

### version 0.2 Stack 

``` python
Time: O(n)
Space: O(n)

class Solution:
    def trap(self, height: List[int]) -> int:
        stack, water = [], 0
        for right, bar in enumerate(height):
            print(stack)
            while stack and height[stack[-1]] < bar:
                top = stack.pop()
                if not stack: 
                    break
                left = stack.pop()
                distance = right - left - 1
                bounded_height = min(height[left], bar) - height[top]
                water += bounded_height * distance 
            stack.append(right)
        return water 
```

## Debug


### wrong answer 


```
[2,1,0,2]
```
- Output: 1
- Expected: 3  

Why?

- `stack[-1]` instead of `stack.pop()` cause we need to use stack[-1] in the next while loop

Before:

``` python 
class Solution:
    def trap(self, height: List[int]) -> int:
        stack, water = [], 0
        for right, bar in enumerate(height):
            print(stack)
            while stack and height[stack[-1]] < bar:
                top = stack.pop()
                if not stack: 
                    break
                left = stack.pop() # debug
                distance = right - left - 1
                bounded_height = min(height[left], bar) - height[top]
                water += bounded_height * distance 
                # print("water:", water)
            stack.append(right)
            # print(stack, water)
            # print()
        return water 
```

After:

``` python
                left = stack[-1]
```