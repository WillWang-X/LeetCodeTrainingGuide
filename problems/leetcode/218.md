# [218](https://leetcode.com/problems/the-skyline-problem/). The Skyline Problem

## Ideas

### 1. Identify the change

``` python 
[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 
[2, 10], [9, 10], [3, 15], [7, 15], [5, 12], ...
 2,       9,       3,       7,       5....  
 # Q: To check if they can be a critical point
 # A: When a height changed
```

* Iterate all point.x 
* Check if the height where point stays at changed, which need a way to get the height of the current situation   

``` python 
def get_skyline(self, buildings):
	points = preprocess(buildings)
	live = [(height, end_x)] # heap to get the highest one
	res = []
	for x, height, end_x in points:
		remove_dead_from_live(live, x)
		add_new_to_live(live, height, end_x)
		if changed(live.first, res): 
			res.append([x, height])
	return res
```

### 2. sweep line algorithm 

```
   *------->
    *-------->
*------>
                   *----->
                       *------>
```

* Sorted Q by `y`: to add all events `*------->`
* Faced with enter event: 
	* Add critical point if event.y > Q.highest
	* add event to Q 
* Faced with leave event:
	* Add critical point if event is the highest
	* remove event from Q


## Code 

### v0.7

``` python
class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        events = self._preprocess(buildings)
        active = [(0, float('inf'))]  # -y, end_x
        points = [(0, -1)]            #  x, y
        
        for x, y, end_x in events:
            while self._expired(active[0][1], x):
                heapq.heappop(active)
            if self._is_height(y): 
                heapq.heappush(active, (y, end_x))
            if self._changed(active[0][0], points[-1][-1]):
                points.append([x, -active[0][0]])
        return points[1:]
    
    def _changed(self, active_height, last_height):
        return -active_height != last_height
    
    def _preprocess(self, buildings):
        left = [(l,-h,r) for l,r,h in buildings]
        right = list(set([(r,0,0) for _,r,_ in buildings]))
        return sorted(left + right)
    
    def _is_height(self, height):
        return height < 0
    
    def _expired(self, active_x, cur_x):
        return active_x <= cur_x     
```

### sweep line algorithm v0.2

``` python
from collections import namedtuple
from bisect import insort, bisect_left

class Solution:
    
    def __init__(self):
        self.Event = namedtuple('Event', ('y', 'x', 'id', 'type'))
        self.enter = 0
        self.leave = 1

    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        events = self._preprocess(buildings)
        active = [self.Event(0, -1, None, self.enter)]
        points = {}

        for e in sorted(events, key=lambda e: e.x):
            if e.type == self.enter:
                if e.y > active[-1].y: 
                    points[e.x] = e.y
                insort(active, e)
            else:
                if self._is_highest(e, active[-1]): 
                    points[e.x] = active[-2].y
                active.pop(bisect_left(active, events[e.id]))
                
        return [[x, points[x]] for x in sorted(points.keys())]
    
    def _preprocess(self, buildings):
        events = [self.Event(Hi, Li, i, 0) for i, (Li, Ri, Hi) in enumerate(buildings)] + [
                  self.Event(Hi, Ri, i, 1) for i, (Li, Ri, Hi) in enumerate(buildings)]
        return events
    
    def _is_highest(self, e1, e2):
        return e1.y == e2.y and e1.id == e2.id
```

## Test

### test 1

```
[[0,2,3],[2,5,3]]
```

## More 

* [The skyline problem](https://briangordon.github.io/2014/08/the-skyline-problem.html)