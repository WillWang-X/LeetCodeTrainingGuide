# Bucket sort 


![counting sort](https://i.imgur.com/8wHW0gq.gif)

## Feature 

1. 线性排序算法包括桶排序、计数排序、基数排序。
2. 线性排序算法的时间复杂度为O(n)。
3. 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。

### bucket sort 

![bucket sort](https://i.imgur.com/JMHrAmO.jpg)

1.算法原理：

* 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。
* 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

2.使用条件

* 要排序的数据需要很容易就能划分成m个
桶，并且桶与桶之间有着天然的大小顺序。
* 数据在各个桶之间分布是均匀的，否则极端情况，数据都被分到一个桶里，那就退化为 O(nlogn) 的排序算法了

3.适用场景

* 桶排序比较适合用在**外部排序**中，因为数据量比较大，内存有限，无法将数据全部加载到内存中。

4.时间复杂度

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

### counting sort

![counting sort](https://i.imgur.com/iLxyDm9.jpg)

1.算法原理

* 1）计数其实就是桶排序的一种特殊情况。
* 2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶
* 3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。

2.使用条件

* 1）只能用在**数据范围不大的**场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；
* 2）计数排序只能给**非负整数**排序，其他类型需要在不改变相对大小情况下，转换为非负整数；比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。


### Radix sort 

![radix sort](https://i.imgur.com/Xkn2hXv.jpg)

1.算法原理（以排序10万个手机号为例来说明）

* 1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
* 2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
* 3）经过11次排序后，手机号码就变为有序的了。
* 4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。

2.使用条件

* 1）要求数据可以分割独立的“位”来比较；
* 2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；
* 3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。
* 反例: string字典序sort, 这种方法就用不了。


## 木桩训练

* [692.Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
* 164.Maximum Gap
* 274.H-Index
* 347.Top K Frequent Elements



## 实际应用

1.  有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB。
2.  高考查分，如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？
3. 排序10万个手机号？
4. 如何根据年龄给100万用户数据排序？
5. 对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？


<br>
<br>

2018.12.28